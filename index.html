<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>CraZyPG</title>
    <style>
        html, body {
            background: black;
            padding: 0px;
            margin: 0px;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        div {
            display: flex;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div>
        <canvas id="glpaper"></canvas>
    </div>
    <script src="./build/czpg.js"></script>
    <img id="test-tex" src="./resource/UV_Grid_Lrg.jpg" style="display:none;"/>
    <script>
        window.addEventListener('load', function() {
            const renderer = new CZPG.Renderer('glpaper', { antialias: true }).setSize('80%', '80%').clear();
            const context = renderer.context;
            const scene = new CZPG.Scene(renderer);
            textures = CZPG.createTextures(context, {
                checker: {
                    mag: context.NEAREST,
                    min: context.LINEAR,
                    src: [
                        255,255,255,255,
                        192,192,192,255,
                        192,192,192,255,
                        255,255,255,255,
                    ],
                },
                pic: { 
                    src : './resource/UV_Grid_Lrg.jpg',
                    min : context.LINEAR_MIPMAP_LINEAR,
                    mag : context.LINEAR,
                },
                cvs: { src : document.getElementById('test-tex')},
                day: {
                    target: context.TEXTURE_CUBE_MAP,
                    src: [
                        './resource/miramar_right.png',
                        './resource/miramar_left.png',
                        './resource/miramar_top.png',
                        './resource/miramar_bottom.png',
                        './resource/miramar_back.png',
                        './resource/miramar_front.png',
                    ]
                },
                night: {
                    target: context.TEXTURE_CUBE_MAP,
                    src: [
                        './resource/grimmnight_right.png',
                        './resource/grimmnight_left.png',
                        './resource/grimmnight_top.png',
                        './resource/grimmnight_bottom.png',
                        './resource/grimmnight_back.png',
                        './resource/grimmnight_front.png',
                    ]
                },
                goldengate: {
                    target: context.TEXTURE_CUBE_MAP,
                    src: './resource/goldengate.jpg',
                },
                barrel: {
                    src : './resource/barrel.png',
                    min : context.LINEAR_MIPMAP_LINEAR,
                    mag : context.LINEAR,
                },
                scalar: {
                    mag: context.NEAREST,
                    min: context.NEAREST,
                    src: [
                        100, 100, 100, 255,
                    ],
                }
            })

            let camera = new CZPG.PerspectiveCamera(45, context.canvas.width/context.canvas.height);
            camera.transform.position.set(0, 1, 3);
            let controler = scene.controler;
            let cameraControler = new CZPG.OrbitControls(camera, context.canvas, controler);
            cameraControler.enableDamping = true;
            // cameraControler.autoRotate = true;

            let gridShader = new CZPG.GridAxisShader(context, camera);
            let gridMesh = CZPG.GridAxis.createMesh();
            let gridModal = new CZPG.Model(gridMesh);

            let quadShader = new CZPG.FlatTextureShader(context, camera, textures.pic);
            let quadModal = CZPG.Quad.createModel().setPosition(2.5, 0.5, 0);
            let cubeModal = CZPG.Cube.createModel().setPosition(-2.5, 0.5, 0);
            let sphereModel = CZPG.Sphere.createModel();//.setPosition(2.5, 0.5, -2.5);
            let sphereOctModel = CZPG.Sphere.createModel('oct-sphere', 0.5, 4, 4, Math.PI * 0, Math.PI * 0.5, 0, Math.PI / 2).setPosition(1.5, 0.5, -2.5);
            sphereOctModel.mesh.cullFace = false;
            // sphereOctModel.setUniformObj({isFlat: false});
            CZPG.addBarycentricAttrib(sphereModel, true);
            CZPG.addBarycentricAttrib(cubeModal, true);
            CZPG.addBarycentricAttrib(quadModal, true);
            CZPG.addBarycentricAttrib(sphereOctModel, true);

            let wireframeShader = new CZPG.WireframeShader(context, camera).setUniformObj( {
                thickness: 0.5,
                screenWidth: false,
                stroke: [ 0 / 255, 157 / 255, 118 / 255, 1.0 ],
                fill: [ 255 / 255, 0 / 255, 0 / 255, 0.0 ],
                backStroke: [ 255 / 255, 88 / 255, 83 / 255, 1.0 ],
                colorBack: true,
                noiseSmall: false,
                noiseBig: false,
                squeeze: false,
                squeezeMin: 0.8,
                suqeezeMax: 1.0,
                dash: false,
                dashRepeats: 6,
                dashLength: 0.5,
                dashOverlap: false,
                dashAnimate: false,
                dualStroke: true,
                secondThickness: 0.1,
                feather: 1.0,
            } );
            let lightShader = new CZPG.PointlightShader(context, camera);
            let phongShader = new CZPG.PhongLightShader(context, camera);
            let objModels = [];
            CZPG.ObjLoader.load('./resource/barrel.obj').then(function(meshs) {
                for (let i = 0; i < meshs.length; i++) {
                    objModels.push((new CZPG.Model(meshs[i])).setScale(0.1, 0.1, 0.1).setUniformObj({
                            ambientColor: [ 0.05, 0.05, 0.05 ],
                            falloff: 0.15,
                            radius: 8.0,
                            // materials
                            shiness: 10.0,
                            specularFactor: 0.1,
                            roughness: 0.6,
                            albedo: 0.9,
                            isFlat: i % 2 === 1,
                            isGamma: true,
                        }));
                }
                // colorPicker.addModels(objModels);
                scene.add([
                    // { shader: phongShader.setTexture(textures.barrel), model: objModels },
                    // { helper: pointHelper, data: objModels.map(m => { return { data: m.positionInfo, transform: m.transform }; } ) },
                ]);
            
            });

            let skymapShader = new CZPG.DynamicSkyboxShader(context, camera, textures.day, textures.night);
            let skyCubeModal = new CZPG.Model(CZPG.Cube.createMesh('sky', 200, 200, 200, 0, 0, 0));

            let pointHelper = new CZPG.PointHelper(context, camera, [0, 0, 0], 8.0);
            let lineHelper = new CZPG.LineHelper(context, camera, cubeModal);

            let terrainModel = CZPG.Terrain.createModel('terrain', 15, 15, 31, 31).setPosition(0, -1, 0);

            let colorPicker = new CZPG.FramebufferPicker(context, camera, controler).activate();
            colorPicker.models = scene.models;

            let curveModel = CZPG.Curve.createModel('cur', [
                new CZPG.Vector3(-2, 0, 0), new CZPG.Vector3(-1.5, 0.4, 0), new CZPG.Vector3(-0.5, 1, 0), new CZPG.Vector3(0, 0, 0),
                                            new CZPG.Vector3(0.5, -1, 0), new CZPG.Vector3(1.5, -0.4, 0), new CZPG.Vector3(2, 0, 0),
            ], 0.001, 40);

            let meshlineShader = new CZPG.MeshLineShader(context, camera).setUniformObj({
                linewidth: 2,
                color: [ 255 / 255, 105 / 255, 180 / 255, 255 / 255 ],
                sizeAttenuation: false,
                visibilityStart: 0.2,
                visibilityEnd: 0.5,
            })
            let meshlineModel = new CZPG.MeshLineModel(curveModel.mesh, meshlineShader);//function( p ) { return Math.abs(Math.sin( Math.PI * 2 * p )); }
            meshlineModel.mesh.blend = true;
            let lightPos = [0, 0, 0];

            scene.add([
                {shader: skymapShader, model: skyCubeModal},
                {shader: gridShader, model: gridModal},
                // {shader: quadShader.setTexture(textures.pic), model: [curveModel]},
                {shader: meshlineShader, model: [meshlineModel]},
                // {shader: wireframeShader, model: [sphereModel, cubeModal, quadModal, sphereOctModel]},
                // {
                //     shader: lightShader.setUniformObj({ isFlat: true, isGamma: false, specularFactor: 0.2, diffuseFactor: 0.6, shiness: 40}),
                //     model: [terrainModel.setUniformObj({texture: textures.scalar})],
                // },
                // {
                //     helper: lineHelper, 
                //     data:[
                //         {data: cubeModal},
                //         {data: terrainModel},
                //     ]
                // },
                {
                    helper: pointHelper,
                    data: [
                        // {data: [0, 0, 0], transform: new CZPG.Transform(), position: lightPos},
                        // {data: curveModel.positionInfo},
                        // {data: meshlineModel.positions},
                    ]
                }
            ]);

            let resized = false;
            let loop = new CZPG.Render(function(timespan) {
                resized = renderer.clear().fixCanvasToDisplay(window.devicePixelRatio)
                if(resized) camera.updateProjMatrix( context.canvas.width / context.canvas.height );
                cameraControler.update();

                lightPos[0] = 2 * Math.cos(performance.now() * 0.0003);
                lightPos[1] = 2 * Math.abs(Math.cos(performance.now() * 0.0003));
                lightPos[2] = 2 * Math.sin(performance.now() * 0.0003);

                skymapShader.setRate( Math.abs( Math.sin( performance.now() * 0.0003) ) );
                terrainModel.addTime(context, timespan * 2);
                lightShader.setUniformObj({ position: lightPos });
                phongShader.setUniformObj({ position: lightPos });
                wireframeShader.setUniformObj({time: performance.now() * 0.005});
                meshlineShader.setUniformObj({
                    visibilityStart: Math.abs( Math.sin( performance.now() * 0.0003) ),
                    visibilityEnd: Math.abs( Math.sin( performance.now() * 0.0003) ) + 0.3,
                })
                // scene.render2Buffer(resized).render2Screen(0);
                scene.render();

                colorPicker.update();

            }).start();
        });
        
    </script>
</body>
</html>