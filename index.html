<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>CraZyPG</title>
    <style>
        html, body {
            background: black;
            padding: 0px;
            margin: 0px;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        div {
            display: flex;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div>
        <canvas id="glpaper"></canvas>
    </div>
    <script src="./build/czpg.js"></script>
    <img id="test-tex" src="./resource/UV_Grid_Lrg.jpg" style="display:none;"/>
    <script id="tf-vs" type="nonjs">#version 300 es

        out vec3 a_position;
        out vec3 a_normal;
        out vec2 a_texcoord;
        flat out uint a_color;

        uniform float u_vertexCount;
        uniform float u_around;
        uniform float u_hue;

        const float PI = radians(180.);

        vec3 hsv2rgb(vec3 c) {
            c = vec3(c.x, clamp(c.yz, 0.0, 1.0));
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            float numQuads = floor(u_vertexCount / 6.);
            float down = numQuads / u_around;
            float quadId = floor(float(gl_VertexID) / 6.);

            float qx = mod(quadId, u_around);
            float qy = floor(quadId / u_around);

            // 0--1 3
            // | / /|
            // |/ / |
            // 2 4--5
            //
            // 0 1 0 1 0 1
            // 0 0 1 0 1 1

            float edgeId = mod(float(gl_VertexID), 6.);
            float ux = mod(edgeId, 2.);
            float vy = mod(floor(edgeId / 2.) + floor(edgeId / 3.), 2.);

            float qu = (qx + ux) / u_around;
            float qv = (qy + vy) / down;

            float r = sin(qv * PI);
            float x = cos(qu * PI * 2.) * r;
            float z = sin(qu * PI * 2.) * r;

            a_position = vec3(x, cos(qv * PI), z);
            a_normal = normalize(a_position);
            a_texcoord = vec2(qu, qv);

            float hue = sin(qu * PI) * .1 + u_hue;
            float sat = mix(0.5, 1., mod(quadId, 2.));
            float val = 1.;
            uvec4 ucolor = uvec4(vec4(hsv2rgb(vec3(hue, sat, val)), 1.) * 255.);
            a_color = (ucolor.r <<  0) |
                    (ucolor.g <<  8) |
                    (ucolor.b << 16) |
                    (ucolor.a << 24) ;
        }
    </script>
    <script id="tf-fs" type="notjs">#version 300 es
        precision mediump float;
        out vec4 o;
        void main() {
        o = vec4(0);
        }
    </script>
    <script>    
        window.addEventListener('load', function() {
            const renderer = new CZPG.Renderer('glpaper', { antialias: true }).setSize('80%', '80%').clear();
            const context = renderer.context;
            const scene = new CZPG.Scene(renderer);

            const feedbackShader = new CZPG.Shader(context, "tf-vs", "tf-fs", {
            // note: you can pass a bufferInfo instead of this array
                transformFeedbackVaryings: [
                "a_position",
                "a_normal",
                "a_texcoord",
                "a_color",
                ],
            });
            const feedbackProgram = feedbackShader.program;
            const feedbackInfo = CZPG.createTransformFeedbackInfo(context, feedbackProgram);

            let numVerts = 20;
            const bufferInfo = CZPG.createBufferInfoFromArrays(context, {
                a_position: numVerts * 3,
                a_normal: numVerts * 3,
                a_texcoord: numVerts * 2,
                a_color: { data: numVerts * 4, type: Uint8Array, },
            });

            const feedback = CZPG.createTransformFeedback(context, feedbackProgram, feedbackInfo, bufferInfo);    

            var model;
            function generateMesh(tf, bufferInfo, numVerts, around, hue) {
                context.enable(context.RASTERIZER_DISCARD);

                feedbackShader.activate();
                context.bindTransformFeedback(context.TRANSFORM_FEEDBACK, tf);
                context.beginTransformFeedback(context.TRIANGLES);
                feedbackShader.setUniformObj({
                    u_vertexCount: numVerts,
                    u_around: around,
                    u_hue: hue,
                });
                var mesh = {
                    name: 'testtst',
                    bufferInfo,
                    drawMode: context.TRIANGLES,
                    attribArrays: {},
                }
                model = new CZPG.Model(mesh);
                feedbackShader.renderModel(model);
                model.vao = undefined;
                context.endTransformFeedback();
                context.bindTransformFeedback(context.TRANSFORM_FEEDBACK, null);

                context.disable(context.RASTERIZER_DISCARD);
            }

            generateMesh(feedback, bufferInfo, 4, 3, 2);

            textures = CZPG.createTextures(context, {
                checker: {
                    mag: context.NEAREST,
                    min: context.LINEAR,
                    src: [
                        255,255,255,255,
                        192,192,192,255,
                        192,192,192,255,
                        255,255,255,255,
                    ],
                },
                pic: { 
                    src : './resource/UV_Grid_Lrg.jpg',
                    min : context.LINEAR_MIPMAP_LINEAR,
                    mag : context.LINEAR,
                },
                cvs: { src : document.getElementById('test-tex')},
                day: {
                    target: context.TEXTURE_CUBE_MAP,
                    src: [
                        './resource/miramar_right.png',
                        './resource/miramar_left.png',
                        './resource/miramar_top.png',
                        './resource/miramar_bottom.png',
                        './resource/miramar_back.png',
                        './resource/miramar_front.png',
                    ]
                },
                night: {
                    target: context.TEXTURE_CUBE_MAP,
                    src: [
                        './resource/grimmnight_right.png',
                        './resource/grimmnight_left.png',
                        './resource/grimmnight_top.png',
                        './resource/grimmnight_bottom.png',
                        './resource/grimmnight_back.png',
                        './resource/grimmnight_front.png',
                    ]
                },
                goldengate: {
                    target: context.TEXTURE_CUBE_MAP,
                    src: './resource/goldengate.jpg',
                },
                barrel: {
                    src : './resource/barrel.png',
                    min : context.LINEAR_MIPMAP_LINEAR,
                    mag : context.LINEAR,
                },
                scalar: {
                    mag: context.NEAREST,
                    min: context.NEAREST,
                    src: [
                        100, 100, 100, 255,
                    ],
                }
            });

            let camera = new CZPG.PerspectiveCamera(45, context.canvas.width/context.canvas.height);
            camera.transform.position.set(0, 1, 3);
            let controler = scene.controler;
            let cameraControler = new CZPG.OrbitControls(camera, context.canvas, controler);
            cameraControler.enableDamping = true;
            // cameraControler.autoRotate = true;

            let gridShader = new CZPG.GridAxisShader(context, camera);
            let gridModal = CZPG.GridAxis.createModel();

            let skymapShader = new CZPG.DynamicSkyboxShader(context, camera, textures.day, textures.night);
            let skyCubeModal = new CZPG.Model(CZPG.Cube.createMesh('sky', 200, 200, 200, 0, 0, 0));

            let colorPicker = new CZPG.FramebufferPicker(context, camera, controler).activate();
            colorPicker.models = scene.models;

            var fshader = new CZPG.FlatTextureShader(context, camera, textures.pic);            

            scene.add([
                {shader: skymapShader, model: skyCubeModal},
                {shader: gridShader, model: gridModal},
                {shader: fshader, model: model},
            ]);

            let resized = false;
            let loop = new CZPG.Render(function(timespan) {
                resized = renderer.clear().fixCanvasToDisplay(window.devicePixelRatio)
                if(resized) camera.updateProjMatrix( context.canvas.width / context.canvas.height );
                cameraControler.update();

                skymapShader.setRate( Math.abs( Math.sin( performance.now() * 0.0003) ) );

                // scene.render2Buffer(resized).render2Screen(0);
                scene.render();

                colorPicker.update();

            }).start();

        });
        
    </script>
</body>
</html>