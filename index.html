<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>CraZyPG</title>
    <style>
        html, body {
            background: black;
            padding: 0px;
            margin: 0px;
            width: 100%;
            height: 100%;
        }

        div#canvas {
            display: flex;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: center;
        }

        div#container{
            width: 100%;
            height: 100%;
        }

        div#footbar{
            position: absolute;
            bottom: 0px;
            right: 20px;
            padding: 10px;
            font-size: 11px;
            font-family: 'Raleway', 'Helvetica', sans-serif;
            color: #222222;
            font-weight: 700;
        }

        div#footbar a{
            color: #44ABDA
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas">
            <canvas id="glpaper"></canvas>
        </div>
    </div>
    <div id="footbar">
        <p><a href="https://github.com/PrincessGod/CraZyPG">CZPG.js</a></p>
    </div>
    <script src="./build/czpg.js"></script>
    <script src="./sample/js/audiostreamsource.min.js"></script>
    <script type='shader' id="v-shader">
        #version 300 es
        // https://twgljs.org/examples/dynamic-buffers.html

        in vec3 a_position;

        uniform mat4 u_mvpMat;

        out vec4 v_color;

        vec3 hsv2rgb(vec3 c) {
            c = vec3(c.x, clamp(c.yz, 0.0, 1.0));
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            gl_Position = u_mvpMat * vec4(a_position, 1.0);
            gl_PointSize = 1.0;
            v_color = vec4(1.0, 1.0, 1.0, 0.005);
        }
    </script>
    <script type="shader" id="f-shader">
        #version 300 es

        precision mediump float;

        in vec4 v_color;

        out vec4 finalColor;

        void main() {
            finalColor = v_color;
        }
    </script>
    <script>

        window.addEventListener('load', function() {
            const renderer = new CZPG.Renderer('glpaper', { antialias: true, preserveDrawingBuffer: true }).setSize('80%', '80%').clear();
            const context = renderer.context;
            const scene = new CZPG.Scene(renderer);
            const controler = scene.controler;

            let camera = new CZPG.PerspectiveCamera(45, context.canvas.width/context.canvas.height);
            camera.transform.position.set(0, 0, 7);
            let cameraControler = new CZPG.OrbitControls(camera, context.canvas, controler);
            cameraControler.enableDamping = true;
            // cameraControler.autoRotate = true;

            const textures = CZPG.createTextures(context, {
                scalar: {
                    mag: context.NEAREST,
                    min: context.NEAREST,
                    src: [
                        200, 100, 100, 255,
                    ],
                }
            });

            const gltfJson = {
                "scenes" : [
                    {
                    "nodes" : [ 0 ]
                    }
                ],

                "nodes" : [
                    {
                    "mesh" : 0
                    }
                ],

                "meshes" : [
                    {
                    "primitives" : [ {
                        "attributes" : {
                        "POSITION" : 1
                        },
                        "indices" : 0
                    } ]
                    }
                ],

                "buffers" : [
                    {
                    "uri" : "data:application/octet-stream;base64,AAABAAIAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAA=",
                    "byteLength" : 44
                    }
                ],
                "bufferViews" : [
                    {
                    "buffer" : 0,
                    "byteOffset" : 0,
                    "byteLength" : 6,
                    "target" : 34963
                    },
                    {
                    "buffer" : 0,
                    "byteOffset" : 8,
                    "byteLength" : 36,
                    "target" : 34962
                    }
                ],
                "accessors" : [
                    {
                    "bufferView" : 0,
                    "byteOffset" : 0,
                    "componentType" : 5123,
                    "count" : 3,
                    "type" : "SCALAR",
                    "max" : [ 2 ],
                    "min" : [ 0 ]
                    },
                    {
                    "bufferView" : 1,
                    "byteOffset" : 0,
                    "componentType" : 5126,
                    "count" : 3,
                    "type" : "VEC3",
                    "max" : [ 1.0, 1.0, 0.0 ],
                    "min" : [ 0.0, 0.0, 0.0 ]
                    }
                ],

                "asset" : {
                    "version" : "2.0"
                }
            };

            let flatShader = new CZPG.FlatTextureShader(context, camera, textures.scalar);
            let gltfLoader = new CZPG.GLTFLoader();
            var meshes = gltfLoader.load(gltfJson).meshes;
            const models = [];
            for(let i = 0; i < meshes.length; i++) {
                const model = new CZPG.Model(meshes[i]);
                models.push(model);
            }

            let gridShader = new CZPG.GridAxisShader(context, camera);
            let gridModal = CZPG.GridAxis.createModel()

            scene.add([
                {shader: gridShader, model: gridModal},
                {shader: flatShader, model: models},
            ]);

            let resized = false;
            let loop = new CZPG.Render(function(timespan) {
                resized = renderer.clear(0,0,0,1).fixCanvasToDisplay(window.devicePixelRatio);
                if(resized) camera.updateProjMatrix( context.canvas.width / context.canvas.height );
                cameraControler.update();
                scene.render();
            }).start();

        });

    </script>
</body>
</html>