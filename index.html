<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>CraZyPG</title>
    <style>
        html, body {
            background: black;
            padding: 0px;
            margin: 0px;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        div {
            display: flex;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div>
        <canvas id="glpaper"></canvas>
    </div>
    <script src="./build/czpg.js"></script>
    <script id='quad-vs' type="shader">#version 300 es
        in vec3 a_position;
        in vec2 a_uv;

        uniform mat4 u_world;
        uniform mat4 u_view;
        uniform mat4 u_proj;

        out highp vec2 v_uv;

        void main() {
            v_uv = a_uv;
            gl_Position = u_proj * u_view * u_world * vec4(a_position, 1.0);
        }
    </script>
    <script id="quad-fs" type="shader">#version 300 es
        precision mediump float;

        in highp vec2 v_uv;

        uniform sampler2D u_texture;

        out vec4 finalColor;

        void main() {
            finalColor = texture(u_texture, vec2(v_uv.s, v_uv.t));
        }
    </script>
    <script id="sky-vs" type="shader">#version 300 es
        in vec4 a_position;

        uniform mat4 u_world;
        uniform mat4 u_view;
        uniform mat4 u_proj;

        out highp vec3 v_uv;

        void main() {
            v_uv = a_position.xyz;
            gl_Position = u_proj * u_view * u_world * vec4(a_position.xyz, 1.0);
        }
    </script>
    <script id="sky-fs" type="shader">#version 300 es
        precision mediump float;

        in highp vec3 v_uv;

        uniform samplerCube u_dayTex;
        uniform samplerCube u_nightTex;
        uniform float u_time;

        out vec4 finalColor;
        void main() {
            finalColor = mix( texture(u_dayTex, v_uv), texture(u_nightTex, v_uv), abs(sin(u_time * 0.0002)));
        }
    </script>
    <img id="test-tex" src="./resource/UV_Grid_Lrg.jpg" style="display:none;"/>
    <script>
        class QuadShader extends CZPG.Shader{
            constructor(gl, projMat) {
                super(gl, 'quad-vs', 'quad-fs');
                this.setProjMatrix(projMat);
                this.texture = null;
                gl.useProgram(null);
            }

            setTexture(tex) {
                this.texture = tex;
                return this;
            }

            preRender() {
                this.setUniforms( { u_texture: this.texture } );
                return this;
            }
        }

        class SkymapShader extends CZPG.Shader {
            constructor (gl, projMat, dayTex, nightTex) {
                super(gl, 'sky-vs', 'sky-fs');
                this.setProjMatrix(projMat);
                this.dayTex = dayTex;
                this.nightTex = nightTex;
                gl.useProgram(null);
            }

            setTime(t) {
                this.setUniforms( { u_time: t } );
                return this;
            }

            preRender() {
                this.setUniforms( { u_dayTex: this.dayTex, u_nightTex: this.nightTex } );
                return this;
            }
        }
        var cp, orib;
        window.addEventListener('load', function() {
            const renderer = new CZPG.Renderer('glpaper', { antialias: true }).setSize('80%', '80%').clear();
            const context = renderer.context;
            textures = CZPG.createTextures(context, {
                checker: {
                    mag: context.NEAREST,
                    min: context.LINEAR,
                    src: [
                        255,255,255,255,
                        192,192,192,255,
                        192,192,192,255,
                        255,255,255,255,
                    ],
                },
                pic: { 
                    src : './resource/UV_Grid_Lrg.jpg',
                    min : context.LINEAR_MIPMAP_LINEAR,
                    mag : context.LINEAR,
                },
                cvs: { src : document.getElementById('test-tex')},
                day: {
                    target: context.TEXTURE_CUBE_MAP,
                    src: [
                        './resource/miramar_right.png',
                        './resource/miramar_left.png',
                        './resource/miramar_top.png',
                        './resource/miramar_bottom.png',
                        './resource/miramar_back.png',
                        './resource/miramar_front.png',
                    ]
                },
                night: {
                    target: context.TEXTURE_CUBE_MAP,
                    src: [
                        './resource/grimmnight_right.png',
                        './resource/grimmnight_left.png',
                        './resource/grimmnight_top.png',
                        './resource/grimmnight_bottom.png',
                        './resource/grimmnight_back.png',
                        './resource/grimmnight_front.png',
                    ]
                },
                goldengate: {
                    target: context.TEXTURE_CUBE_MAP,
                    src: './resource/goldengate.jpg',
                },
                barrel: {
                    src : './resource/barrel.png',
                    min : context.LINEAR_MIPMAP_LINEAR,
                    mag : context.LINEAR,
                }
            })

            let camera = new CZPG.PerspectiveCamera(45, context.canvas.width/context.canvas.height);
            camera.transform.position.set(0, 1, 3);
            let cameraControler = new CZPG.OrbitControls(camera, context.canvas);
            cameraControler.autoRotate = true;

            let gridShader = new CZPG.GridAxisShader(context, camera.projMat);
            let gridMesh = CZPG.Primatives.GridAxis.createMesh();
            let gridModal = new CZPG.Model(gridMesh);

            let quadShader = new QuadShader(context, camera.projMat).setTexture(textures.pic);
            let quadModal = CZPG.Primatives.Quad.createModel().setPosition(2.5, 0.5, 0);
            let cubeModal = CZPG.Primatives.Cube.createModel().setPosition(-2.5, 0.5, 0);
            
            let objShader = new QuadShader(context, camera.projMat).setTexture(textures.barrel);
            let objModels = [];
            let objModelCount = 0;
            CZPG.ObjLoader.load('./resource/barrel.obj').then(function(meshs) {
                objModelCount = meshs.length;
                for (let i = 0; i < objModelCount; i++) {
                    objModels.push((new CZPG.Model(meshs[i])).setScale(0.1, 0.1, 0.1));
                }
                console.log(meshs);
            });

            let skymapShader = new SkymapShader(context, camera.projMat, textures.day, textures.night);
            let skyCubeModal = new CZPG.Model(CZPG.Primatives.Cube.createMesh('sky', 500, 500, 500, 0, 0, 0));

            let loop = new CZPG.Render(function(timespan) {
                if (renderer.clear().fixCanvasToDisplay(window.devicePixelRatio))
                    camera.updateProjMatrix( context.canvas.width / context.canvas.height );
                cameraControler.update();
                skymapShader.activate().preRender().setProjMatrix(camera.projMat).setViewMatrix(camera.getOrientMatrix())
                    .setTime(performance.now()).renderModel(skyCubeModal);
                gridShader.activate().setProjMatrix(camera.projMat).setViewMatrix(camera.viewMat)
                    .renderModel(gridModal.preRender());
                quadShader.activate().preRender().setProjMatrix(camera.projMat).setViewMatrix(camera.viewMat)
                    .renderModel(cubeModal.preRender()).renderModel(quadModal.preRender());
                if (objModels){
                    objShader.activate().preRender().setProjMatrix(camera.projMat).setViewMatrix(camera.viewMat);
                    for (let i = 0; i < objModelCount; i ++) {
                        objShader.renderModel(objModels[i].preRender());
                    }
                }
                        
            }).start();
        });
        
    </script>
</body>
</html>